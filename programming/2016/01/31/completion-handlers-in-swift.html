<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Completion Handlers in Swift | grant.ai</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="Completion Handlers in Swift" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’m currently learning the MVVM design pattern and I’ve noticed that a lot of asynchronous code manipulation/organization requires the basic creation of completion handling functions." />
<meta property="og:description" content="I’m currently learning the MVVM design pattern and I’ve noticed that a lot of asynchronous code manipulation/organization requires the basic creation of completion handling functions." />
<link rel="canonical" href="https://grant.ai/programming/2016/01/31/completion-handlers-in-swift.html" />
<meta property="og:url" content="https://grant.ai/programming/2016/01/31/completion-handlers-in-swift.html" />
<meta property="og:site_name" content="grant.ai" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-01-31T14:00:00-05:00" />
<script type="application/ld+json">
{"url":"https://grant.ai/programming/2016/01/31/completion-handlers-in-swift.html","description":"I’m currently learning the MVVM design pattern and I’ve noticed that a lot of asynchronous code manipulation/organization requires the basic creation of completion handling functions.","headline":"Completion Handlers in Swift","datePublished":"2016-01-31T14:00:00-05:00","dateModified":"2016-01-31T14:00:00-05:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://grant.ai/programming/2016/01/31/completion-handlers-in-swift.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://grant.ai/feed.xml" title="grant.ai" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">grant.ai</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">Grant H. Park</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Completion Handlers in Swift</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-01-31T14:00:00-05:00" itemprop="datePublished">Jan 31, 2016
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I’m currently learning the MVVM design pattern and I’ve noticed that a lot of asynchronous code manipulation/organization requires the basic creation of completion handling functions.</p>

<p>Before, I always made messy code in my view controllers that looked sort of like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let kidQuery = PFQuery(className: “_User”)
let theseKids = kidQuery.whereKey(“parent”, containsString: (PFUser.currentUser()?.objectId!)! as String)
theseKids.findObjectsInBackgroundWithBlock { (result, error) -&gt; Void in

  if error == nil {

    self.kidArray = result! as [PFObject] ?? []
    Kids.sharedData.array = self.kidArray as! [PFObject]
    if self.kidArray == [] {
        print(“empty!!”)
    }
    self.tableView.reloadData()
    self.refreshCtrl.endRefreshing()

  } else {

    dispatch_async(dispatch_get_main_queue(), { () -&gt; Void in
    let alert = UIAlertController(title: “Error”, message: error?.localizedDescription, preferredStyle: .Alert)
    let cancel = UIAlertAction(title: “Close”, style: .Default, handler: nil)
    alert.addAction(cancel)
    self.presentViewController(alert, animated: true, completion: nil)

    })
  }
}
</code></pre></div></div>

<p>After I moved my code around, the same function in my view controller looks a lot cleaner:</p>

<p><code class="highlighter-rouge">Tools.kidQuery(self, senderTableView: theTableView, senderRefresh: refreshCtrl, completionHandler: nil)</code></p>

<p>Essentially, I went from 20 lines of code to just 1 for this function, making my view controller less cluttered. I also have all of my data logic contained in their own separate classes. This makes debugging, testing, and adding new app features much easier for me. More importantly, it improves the readability of my project.</p>

<p>To make a lot of these changes to my code, I ran into creating functions with completion handlers. Now I’ll show you how to make your own.</p>

<p>Create a new .swift file. Let’s call it Toolbox.swift and put inside the following function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func testCompletionHandler(input: String?, completionHandler: ((result: String?) -&gt; Void)?) {}

Note that the “input” and “completionHandler” arguments in this function are optional; you could call this function with nil for both arguments and it could still do something (or do nothing at all). The “completionHandler” argument is actually a Swift block that can execute something along with a parameter called “result.” Right now, this function does nothing, so let’s add some logic:

func testCompletionHandler(input: String?, completionHandler: ((result: String?) -&gt; Void)?) {

  if let aString = input {
    if aString == “I want a completion handler!” {
      if let aHandler = completionHandler {
        aHandler(result: “Here is the completion handler!”)
      }
    } else {
      if let aHandler = completionHandler {
        aHandler(result: nil)
      }
    }
  }
}
</code></pre></div></div>

<p>The moment “aHandler” is called inside of this function, the caller of this function will receive the completion block and can do anything they want with “result” unless it’s nil of course.</p>

<p>As an example, let’s look at ViewController.swift (a different source file):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ViewController: UIViewController {

  var myToolbox = Toolbox()

  viewDidLoad() {
      super.viewDidLoad()
      myToolbox.testCompletionHandler("I want a completion handler!") { (result) -&gt; Void in 
        if let aString = result { print(aString) }
      }
    }
  }
}
</code></pre></div></div>

<p>When we call our created completion handler function in viewDidLoad, we should receive “Here is the completion handler!” in the console. We’ve successfully created a completion handler function and now you can use this same pattern to move all your asynchronous logic to specialized classes for ultimately cleaner, more readable code!</p>


  </div><a class="u-url" href="/programming/2016/01/31/completion-handlers-in-swift.html" hidden></a>
</article>

      </div>
    </main></body>

</html>
